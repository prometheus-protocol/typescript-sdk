/**
 * @module
 * This module provides the server-side client and utilities for interacting with the
 * Prometheus Protocol from a secure backend environment like Node.js.
 */

import { HttpAgent, type Identity } from '@dfinity/agent';
import { Principal } from '@dfinity/principal';
import * as fs from 'node:fs';
import {
  IcrcLedgerCanister,
  type TransferFromParams,
} from '@dfinity/ledger-icrc';

export { identityFromPem, identityFromPemContent } from './identity.js';

/**
 * Represents the structure of the token metadata stored in prometheus-tokens.json.
 */
export interface TokenInfo {
  canister_id: string; // Stored as text in the JSON file
  symbol: string;
  decimals: number;
}

/**
 * Defines the configuration for the PrometheusServerClient.
 */
export interface ServerClientConfig {
  /**
   * The server's own identity, typically loaded from a secure PEM file.
   */
  identity: Identity;
  /**
   * The Principal that will receive the funds from charges.
   */
  payoutPrincipal: Principal;
  /**
   * The host URL for the Internet Computer. Defaults to `https://icp-api.io`.
   */
  host?: string;
  /**
   * Explicitly set whether to fetch the root key for local development.
   */
  fetchRootKey?: boolean;
  /**
   * The path to the token metadata file generated by the config script.
   */
  tokenConfigPath?: string;
}

/**
 * Defines the arguments for the `charge` method.
 */
export interface ChargeOptions {
  /** The Principal of the user to be charged. This should be securely extracted from a validated JWT. */
  userToCharge: string | Principal;
  /** The amount to charge, specified in whole tokens (e.g., 0.01). */
  amount: number;
}

/**
 * A helper function to parse the structured error from the ICRC ledger.
 * @param error The error object thrown by the ledger canister.
 * @returns A human-readable error string.
 */
function parseIcrcError(error: any): string {
  if (error && typeof error === 'object' && 'errorType' in error) {
    const { errorType } = error;
    const key = Object.keys(errorType)[0];
    const value = errorType[key];

    switch (key) {
      case 'InsufficientAllowance':
        return `Insufficient allowance: The user has not approved a large enough spending limit for this server. Current allowance: ${Number(value.allowance) / 1e8} tokens.`;
      case 'InsufficientFunds':
        return `Insufficient funds: The user's wallet balance is too low. Current balance: ${Number(value.balance) / 1e8} tokens.`;
      case 'BadFee':
        return `Bad fee: The transaction fee was incorrect. Expected: ${Number(value.expected_fee) / 1e8} tokens.`;
      case 'Duplicate':
        return `Duplicate transaction: This transaction has already been processed. Duplicate of block: ${value.duplicate_of}.`;
      case 'TemporarilyUnavailable':
        return 'The ledger is temporarily unavailable. Please try again later.';
      case 'TooOld':
        return 'The transaction is too old to be processed.';
      default:
        return `An unknown ledger error occurred: ${JSON.stringify(errorType)}`;
    }
  }
  return error instanceof Error ? error.message : 'An unknown error occurred.';
}

/**
 * Represents the outcome of a charge operation.
 */
export type ChargeResult =
  | { ok: true; blockIndex: bigint }
  | { ok: false; error: string };

/**
 * The main client for interacting with the Prometheus Protocol from a secure server
 * environment (e.g., Node.js). It handles direct, authenticated calls to ICRC-2 ledgers.
 */
export class PrometheusServerClient {
  private agent: HttpAgent;
  private payoutPrincipal: Principal;
  private tokenConfigPath: string;
  private tokenInfoCache: TokenInfo[] | null = null;

  /**
   * Creates an instance of the PrometheusServerClient.
   * @param config The configuration for the client.
   */
  constructor(config: ServerClientConfig) {
    const host = config.host ?? 'https://icp-api.io';
    const fetchRootKey =
      config.fetchRootKey ??
      (host.includes('localhost') || host.includes('127.0.0.1'));

    this.agent = new HttpAgent({
      host,
      identity: config.identity,
      shouldFetchRootKey: fetchRootKey,
    });

    this.payoutPrincipal = config.payoutPrincipal;
    this.tokenConfigPath = config.tokenConfigPath || './prometheus-tokens.json';
  }

  /**
   * A private helper to lazily load token info from the local config file.
   */
  private async getSupportedTokens(): Promise<TokenInfo[]> {
    if (this.tokenInfoCache !== null) {
      return this.tokenInfoCache;
    }

    try {
      const fileContent = fs.readFileSync(this.tokenConfigPath, 'utf-8');
      const tokens: TokenInfo[] = JSON.parse(fileContent);
      if (tokens.length === 0) {
        throw new Error('Token configuration file is empty.');
      }
      this.tokenInfoCache = tokens;
      return this.tokenInfoCache;
    } catch (error) {
      console.error(
        `Failed to load or parse token metadata from ${this.tokenConfigPath}.`,
      );
      throw new Error(
        `Configuration error: Please ensure '${this.tokenConfigPath}' exists and is valid. Run 'npx prometheus-cli' if needed.`,
      );
    }
  }

  /**
   * Charges a user by executing an `icrc2_transfer_from` call.
   * This method automatically uses the first payment token configured in the
   * prometheus-tokens.json file and handles the conversion from a token amount
   * to the correct number of e8s based on the token's decimals.
   *
   * @param options An object containing the details of the charge.
   * @returns A promise that resolves to a result object indicating the outcome of the charge.
   */
  public async charge(options: ChargeOptions): Promise<ChargeResult> {
    try {
      // Step 1: Lazily get the token info from the local file.
      const supportedTokens = await this.getSupportedTokens();
      // For now, default to the first supported token.
      const tokenToUse = supportedTokens[0];

      const ledgerCanister = IcrcLedgerCanister.create({
        agent: this.agent,
        canisterId: Principal.fromText(tokenToUse.canister_id),
      });

      const userToCharge =
        typeof options.userToCharge === 'string'
          ? Principal.fromText(options.userToCharge)
          : options.userToCharge;

      // Convert the token amount to the smallest unit (e.g., e8s)
      const amountInSmallestUnit = BigInt(
        Math.round(options.amount * 10 ** tokenToUse.decimals),
      );

      // Step 2: Execute the charge. This is the only network call.
      const transferArgs: TransferFromParams = {
        from: { owner: userToCharge, subaccount: [] },
        to: { owner: this.payoutPrincipal, subaccount: [] },
        amount: amountInSmallestUnit,
      };

      const txId = await ledgerCanister.transferFrom(transferArgs);

      return { ok: true, blockIndex: txId };
    } catch (e) {
      const errorMessage = parseIcrcError(e);
      console.error('Charge operation failed:', errorMessage);
      return { ok: false, error: errorMessage };
    }
  }
}
